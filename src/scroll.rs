use crate::stats::Stats;

/// A scroll. Contains all of the usual information associated with a scroll,
/// in addition to its nominal cost.
#[derive(Clone, Debug, PartialEq)]
pub struct Scroll {
    /// Probability of success.
    pub p_suc: f64,
    /// Is this a dark scroll?
    pub dark: bool,
    /// How much the scroll costs.
    pub cost: f64,
    /// What stats the scroll grants on success.
    pub stats: Stats,
}

impl Scroll {
    /// Creates a new scroll from the probability of success (`p_suc`), whether
    /// or not the scroll is dark (`dark`), what the nominal cost of the scroll
    /// is (`cost`), and what stats the scroll grants on success (`stats`).
    pub const fn new(p_suc: f64, dark: bool, cost: f64, stats: Stats) -> Self {
        Self {
            p_suc,
            dark,
            cost,
            stats,
        }
    }

    /// Generates a "master scroll" based on a set of `Scroll`s. The master
    /// scroll has a 100% probability of success, is not a dark scroll, has a
    /// cost equal to [positive
    /// infinity](https://en.wikipedia.org/wiki/Extended_real_number_line), and
    /// grants a bonus to each stat that is equal to the highest bonus granted
    /// to that stat by any of the scrolls in the input set.
    ///
    /// Basically, the `stats` member of the master scroll is generated by
    /// summing up all of the `stats` members of the elements of the input set
    /// (`scrolls`), if you think of each `Stats` struct as an element of a
    /// [max tropical](https://en.wikipedia.org/wiki/Tropical_semiring)
    /// [semimodule](https://en.wikipedia.org/wiki/Semimodule).
    ///
    /// ## Invariants:
    ///
    /// - `!scrolls.is_empty()`
    /// - Every stat array of every scroll in `scrolls` is of equal length.
    pub fn master_scroll(scrolls: &[Self]) -> Self {
        debug_assert!(!scrolls.is_empty());
        debug_assert!(scrolls
            .iter()
            .map(|s| s.stats.len())
            .all(|l| l == scrolls[0].stats.len()));

        let mut master = Self::new(
            1.0,
            false,
            f64::INFINITY,
            Stats::from_vec(vec![0; scrolls[0].stats.len()]),
        );

        for scroll in scrolls {
            master.stats.max_in_place(&scroll.stats);
        }

        master
    }
}
